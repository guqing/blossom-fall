# 注解


## 1.什么是注解
- 语法：@注解名称
- 注解的作用：替代xml配置文件
- servlet3.0中就可以不在使用web.xml文件，而是所有配置文件都使用注解。
- 注解是由框架来读取的！

## 2.注解的使用！
- 定义注解类(框架的工作)
- 使用注解（我们的工作）
- 读取注解（反射读取注解)(框架的工作）
>  注解其实也是一个类

## 3.如何定义注解类
class A{}定义类
interface A{}定义接口

**@interface A{} 定义注解**
- 天下所有的注解都是Annotation的子类
不用特意标记默认就是

## 4.如何使用注解
```java
package annotation;
@MyAnnotation//注解能放在类上
public class Demo1 {
	@MyAnnotation//注解能放在成员变量上
	private String name;
	
	@MyAnnotation//注解能放在构造器上
	public void Demo1(){
		
	}
	
	@MyAnnotation//注解能放在方法上
	public void test1(){
		
	}
	
	public void test2(@MyAnnotation String name){//注解能放在参数上
		//注解能放在局部变量上
		@MyAnnotation
		String username = "hello";
	}
	//但是注解不能放在方法的调用上
	
}
```
```java
//自定义注解类
package annotation;
@interface MyAnnotation {
	
}
```

### 综上所述：注解的作用目标
- 类
- 方法
- 构造器
- 参数
- 局部变量
- 包

## 5.注解的属性（依赖文档了解）
- 定义属性
```java
格式：类型 属性名()
例如：
//注解类
@interface MyAnno1{
	int age();//这是属性不是方法
	String name();//括号后面不能跟{}，也不能加参数，这不是方法
}
```

- 使用注解时给属性赋值
```java
//使用属性时，属性必须要求有值
@MyAnno1(age=100,name="zhangsan")
```

- 注解属性的默认值
```java
//注解类
@interface MyAnno2{
	int age() default 100;//这是属性不是方法
	String name();
}
使用时：@MyAnno2(name="zhangsan")
也可以在给一个age值如：
@MyAnno2(age="999",name="zhangsan")
此时值会覆盖默认值
```

- 名为value的属性的特权
```java
在使用注解时，如果只给名为value的属性赋值，那么可以不给出属性的名称直接给出值
例如：
//注解的特权
@interface MyAnno3{
	int value();
	String name() default "hello world";
}
使用注解时：
@MyAnno3(100)相当于给value的属性赋值不用指定value
```

- 注解属性的类型
```java
注解属性有8中基本类型：
- String
- Enum
- Class
- 注解类型(和循环体的内容是循环体是一个道理）
- 以上类型的一维数组类型 int[],(二维数组不行)
注意：Integer包装类型不能使用

如何使用：
@interface MyAnno4{
	int a();
	String b();
	MyEnum c();
	Class d();
	MyAnno2 e();
	String[] f();
}
enum MyEnum{
	A,B,C
}

@MyAnno4(
	a=100,
	b="hello",
	c=MyEnum.A,
	d=String.class,
	e=@MyAnno2(name = "zhangsan"),
	f={"hello","world"}
)
public class Demo3 {

}
当给数组类型的属性赋值时，可以省略大括号
如f="hello"
```


## 6.注解的作用目标限定以及保存策略限定
### 6.1让一个注解他的作用目标只能在类上不能在方法上，这就叫做目标的限定
- 在定义注解时给注解添加注解叫做@Target
```java
@Target(value={ElementType.TYPE,ElementType.ANNOTATION_TYPE,ElementType.METHOD,ElementType.FIELD})
@interface MyAnno1{
	
}
```
### 6.2保留策略
- 源代码文件（SOURCE）：注解只在源代码中存在，在编译时就别忽略了（无法反射）
- 字节码文件(CLASS)：注解在源代码中存在，编译时会把注解信息放到class中存在，但JVM在类时会被忽略加载注解（无法反射）
- JVM中(RUNTIME)：注解在源代码，字节码文件中存在，并且在JVM加载类时会把注解加载到JVM内存中（它是唯一可以反射的注解）

**限定注解的而保留策略**
```java
@Retention(RetentionPolicy.RUNTIME)//保留策略
@interface MyAnno1{
	
}
```
## 7.读取注解


## 反射泛型信息
Class --> Type getGenericSuperclass()
Type --> ParameterizedType,把Type强转为ParameterizedType类型
ParameterizedType --> 参数化类型 = A<String>
ParameterizedType :Type[]  getActualTypeArguments(),A<String>中的String
Type[]就是Class[],我们就得到了类型参数了!
```java
public class Demo1 {
	@Test
	public void fun1(){
		new B();//执行得到java.lang.String
	}
}
class A<T> {
	public A() {
		/*
		 * 在这里获取子类传递的泛型信息，要得到一个Class
		 */
//		Class clazz = this.getClass();//得到子类的类型
//		Type type = clazz.getGenericSuperclass();//获取传递给父类参数化类型
//		ParameterizedType pType=(ParameterizedType)type;//它就是A<String>
//		Type[] types = pType.getActualTypeArguments();//它就是一个Class数组
//		Class c = (Class)types[0];
//		System.out.println(c.getName());//String或Integer
		
		//变成一句话
		Class c = (Class)((ParameterizedType)(this.getClass().
				getGenericSuperclass())).getActualTypeArguments()[0];
		System.out.println(c.getName());
	}
}
class B extends A<String> {
	
}
class C extends A<Integer> {
	
}
```
## 反射注解
### 1.要求
- 注解的保留策略必须是RUNTIME

### 2.反射注解需要从作用目标开始反射
- 类上的注解，需要使用Class来获取
- 方法上的注解需要Method来获取
- 构造器上的注解需要Constructor来获取
- 成员山谷的需要使用Field来获取

一下拥有可以获取注解的方法：
- Class:
- Method、Constructor、Field有共同的父类：AccessibleObject
它们都有一个方法：
- Annotation getAnnotation(Class),返回目标上指定类型的注解
- Annotation[] getAnnoations(),返回目标注解上所有的注解
```java
 public class Demo2 {
       @Test
	public void test1(){
		/*
		 * 1.得到作用目标
		 */
		Class<A> c = A.class;
		/*
		 * 2.获取指定类型的注解
		 */
		MyAnno1 myAnno1 = c.getAnnotation(MyAnno1.class);
		System.out.println(myAnno1);//结果@demo2.MyAnno1(name=A类, age=20, sex=男)
	}

    @Test
	public void test2() throws NoSuchMethodException, SecurityException{
		/*
		 * 1.得到作用目标
		 */
		Class<A> c = A.class;
		Method method = c.getMethod("test");
		
		/*
		 * 2.获取指定类型的注解(获取方法上的注解)
		 */
		MyAnno1 myAnno1 = method.getAnnotation(MyAnno1.class);
		System.out.println(myAnno1.name()+ ", " + myAnno1.age() + ", " +myAnno1.sex());
	}
}

@MyAnno1(name="A类",age=20,sex="男")
class A{
	@MyAnno1(name="test1方法",age=10,sex="女")
	public void test(){
		
	}
}
@Retention(RetentionPolicy.RUNTIME)//注意声明保留策略，否则获取不到
@interface MyAnno1 {
	String name();
	int age();
	String sex();
}

```


