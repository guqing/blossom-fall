# 反射泛型和反射注解的应用案例


```java
package testanno;
/**  
* <p>Title: User.java</p>  
* <p>Description: </p>  
* <p>Copyright: Copyright (c) 2018</p>  
* @author guqing   
* @date 2018年9月23日  
* @version 1.0  
*/

import guqing.basedao.Column;
import guqing.basedao.ID;
import guqing.basedao.Table;

/**  
* <p>Title: User</p>  
* <p>Description: </p>  
* @author guqin  
* @date 2018年9月23日  
*/
@Table("user")//它的值表示当前类对应的表
public class User {
	@ID("u_id")//当前属性对应的列明，而且说明这个列是主键列
	private String uid;
	
	@Column("uname")
	private String username;
	
	@Column("password")
	private String password;
	
	@Column("state")
	private boolean state;
	
	@Column("price")
	private double price;
	
	public User() {
	}

	public String getUid() {
		return uid;
	}

	public void setUid(String uid) {
		this.uid = uid;
	}

	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public boolean isState() {
		return state;
	}

	public void setState(boolean state) {
		this.state = state;
	}

	public double getPrice() {
		return price;
	}

	public void setPrice(double price) {
		this.price = price;
	}

	@Override
	public String toString() {
		return "User [uid=" + uid + ", username=" + username + ", password=" + password + ", state=" + state
				+ ", price=" + price + "]";
	}
}

```

```java
/**  
* <p>Title: BaseDao1.java</p>  
* <p>Description: </p>  
* <p>Copyright: Copyright (c) 2018</p>  
* @author guqing   
* @date 2018年9年23日  
* @version 1.0  
*/ 
package guqing.basedao;

import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;

import cn.itcast.jdbc.TxQueryRunner;

/**  
* <p>Title: BaseDao1</p>  
* <p>Description: </p>  
* @author guqin  
* @date 2018年9月23日  
*/
public class BaseDao<T> {
	private QueryRunner qr = new TxQueryRunner();
	private Class<T> beanClass;//通过父类获取子类类型
	private String primaryName;//Dao主键字段名称
	private String tablename;//表名称
	private Map<String,String> mappingField;//存储字段映射
	//获取到MappingField对象
	private MatchField matchField = MatchField.getMatchFieldInstance();
	
	//构造方法
	@SuppressWarnings("unchecked")
	public BaseDao(){
		//通过父类获取子类类型
		beanClass = (Class<T>)((ParameterizedType)this.getClass().getGenericSuperclass()).getActualTypeArguments()[0];
		
		//先获取字段映射Map
		mappingField = matchField.MappingField2Map(beanClass);
		//再获取主键名称
		primaryName = matchField.getBeanPrimaryName();
		
		//获取到表名称
		Table table = beanClass.getAnnotation(Table.class);
		if(table!=null){
			tablename = table.value();
			
		} else {
			String clazzSimpleName = beanClass.getSimpleName();
			tablename = clazzSimpleName.substring(0, 1).toLowerCase() + clazzSimpleName.substring(1);
		}
	}
	
	public void save(T bean) throws SQLException{
		//String sql ="insert into 表名 values(几个?)";
		
		//通过反射将类中属性的个数清楚就是问号的个数
		Field[] fields = beanClass.getDeclaredFields();

		//获取成员变量上的注解
		List<Object> params = new LinkedList<Object>();
		
		String sql ="insert into " + "`"+tablename +"`"+" values(";
		//拼凑sql字符串
		for(int i=0;i<fields.length;i++){
			sql += "?";
			//拼凑参数
			try {
				params.add(beanClass.getMethod(getGetMethodString(fields[i].getName())).invoke(bean));
			} catch (Exception e) {
				
				try {
					Object param = beanClass.getMethod(getIsMethodString(fields[i].getName())).invoke(bean);
					if(param=="false"){
						params.add(0);
					}else if(param=="true"){
						params.add(1);
					}else{
						params.add(param);
					}
					
				} catch (Exception e1) {
					e1.printStackTrace();
				}
			}
			if(i < fields.length-1){
				sql +=",";
			}
		}
		sql += ")";
		
		qr.update(sql,params.toArray());
	}
	
	
	/**
	* @Title: update  
	* @Description: 更新方法  
	* @param @param bean
	* @return void
	* @throws
	 */
	public void update(T bean){
		try {
			Map<String,Object[]> updateSqlParam = bean2UpdateSql(bean);
			
			/*
			 * update car_number_track set ...+where cid=cid子句
			 */
			qr.update((String) updateSqlParam.get("sql")[0], updateSqlParam.get("params"));
		} catch (SQLException e) {
			throw new RuntimeException(e);
		}
	}

	
	/**
	* @Title: baseDelete  
	* @Description: 根据主键删除  
	* @param @param id
	* @param @return
	* @return Boolean
	* @throws
	 */
     public void deleteById(Object id){
         try{
     		String sql = "delete from " + "`" + tablename +"`"+ " where " + mappingField.get(primaryName) +"=?";
     		
     		qr.update(sql,id);
         } catch (Exception e) {
             e.printStackTrace();
            throw new RuntimeException(e);
         }
     }     
		
     
     /**
     * @Title: get  
     * @Description: 通过主键查询  
     * @param @param id
     * @param @return
     * @return T
     * @throws
      */
     public T get(Object id) {
    	 try {
    		String preSelectSql =  matchField.precursorSelectSql(beanClass);
    		preSelectSql = preSelectSql + "from " + "`" + tablename +"`" + " where " + mappingField.get(primaryName)+"=?";
    		
			return qr.query(preSelectSql, new BeanHandler<T>(beanClass),id);
		} catch (SQLException e) {
			throw new RuntimeException(e);
		}
     }
     
     /**
     * @Title: list  
     * @Description: 查询方法  
     * @param @return
     * @return List<T>
     * @throws
      */
     public List<T> list(){
    	try {
    		//查询语句的前半部分 + 用户自定义的后半部分查询语句
    		String querySql = matchField.precursorSelectSql(beanClass) + Query.getThatSql();
    		
    		if(querySql.contains(":")||querySql.contains("?")){
    			throw new RuntimeException("Syntax error: the number of parameters is insufficient."
    					+ " Please try again after checking[大哥参数个数没给够]");
    		}
    		
			return qr.query(querySql, new BeanListHandler<T>(beanClass));
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
     }

	/**
	* @Title: getGetMethodString  
	* @Description: 通过成员变量属性名称获取到set方法  
	* @param @param fieldName
	* @param @return
	* @return String
	* @throws
	 */
	private String getGetMethodString(String fieldName) {
		String getMethodString = "get" + fieldName.substring(0, 1).toUpperCase() +
				fieldName.substring(1);
		return getMethodString;
	}
	
	private String getIsMethodString(String fieldName) {
		String getMethodString = "is" + fieldName.substring(0, 1).toUpperCase() +
				fieldName.substring(1);
		return getMethodString;
	}

	private Map<String,Object[]> bean2UpdateSql(T bean){
		List<Object> params = new ArrayList<Object>();
		Map<String,Object[]> updateSqlParams = new HashMap<String,Object[]>();
		
		//给出sql语句的前半部分
		StringBuilder firstHalfSql = new StringBuilder("update "+"`"+tablename+"`");//前缀
		StringBuilder setSql = new StringBuilder();//后缀
		
		Object primaryValue = null;
		//先在第一个占位符也就是cid出添加参数
		setSql.append(" set "+"`"+mappingField.get(primaryName)+"`"+"=?");
		try {
			primaryValue = beanClass.getMethod(getGetMethodString(primaryName)).invoke(bean); 
			params.add(primaryValue);
		} catch (Exception e) {
			throw new RuntimeException(e);
		} 
		
		/*
		 * 1.判断条件，完成sql中追加where子句
		 * 2.创建ArrayList，保存参数
		 */
		Field[] fields = beanClass.getDeclaredFields();
		for(Field field : fields){
			if(field.getName().equals(primaryName)){
				continue;//略过主键
			}
			Column column = field.getAnnotation(Column.class);
			try {
				String returnType = beanClass.getMethod(getGetMethodString(field.getName())).getGenericReturnType().getTypeName();
				Object getMethod = beanClass.getMethod(getGetMethodString(field.getName())).invoke(bean);
			
				if(returnType.contains("String")||returnType.contains("Integer")){
					String param = (String) getMethod;
					if(param!=null && !param.trim().isEmpty() && param!="null" && column!=null){
						setSql.append(","+"`"+column.value()+"`"+"=?");
						params.add(param);
						
					} else if(param!=null && !param.trim().isEmpty() && param!="null" && column==null) {
						setSql.append(","+"`"+ mappingField.get(field.getName()) +"`"+"=?");
						params.add(param);
					}
				}else if(returnType.contains("double")){
					double param =  (double)getMethod;
					if(param!=0.0 && column!=null){
						setSql.append(","+"`"+column.value()+"`"+"=?");
						params.add(param);
						
					} else if(column==null) {
						setSql.append(","+"`"+ mappingField.get(field.getName()) +"`"+"=?");
						params.add(param);
					}
				}else if(returnType.contains("int")){
					int param = (int) getMethod;
					if(param!=0 && column!=null){
						setSql.append(","+"`"+column.value()+"`"+"=?");
						params.add(param);
						
					} else if(column==null) {
						setSql.append(","+"`"+ mappingField.get(field.getName()) +"`"+"=?");
						params.add(param);
					}
				} else if(returnType.contains("boolean")){
					Object param =  (Object)getMethod;
					if(column!=null && param!=null && !param.equals("null")){
						setSql.append(","+"`"+column.value()+"`"+"=?");
						params.add((boolean)param);
						
					} else if(param==null){
						continue;
					}else{
						setSql.append(","+"`"+ mappingField.get(field.getName()) +"`"+"=?");
						params.add((boolean)param);
					}
				}
			} catch (Exception e) {
				try {
					String returnType = beanClass.getMethod(getIsMethodString(field.getName())).getGenericReturnType().getTypeName();
					Object getMethod = beanClass.getMethod(getIsMethodString(field.getName())).invoke(bean);
					
					if(returnType.contains("boolean")){
						Object param =  (Object)getMethod;
						if(column!=null && param!=null && !param.equals("null")){
							setSql.append(","+"`"+column.value()+"`"+"=?");
							params.add((boolean)param);
							
						} else if(param==null){
							continue;
						}else{
							setSql.append(","+"`"+ mappingField.get(field.getName()) +"`"+"=?");
							params.add((boolean)param);
						}
					}
				} catch (Exception e1) {
					e1.printStackTrace();
				}
			}
			
		}
		/*
		 * 追加where语句的参数
		 */
		String finalSql = firstHalfSql.append(setSql).append(" where "+
						"`"+mappingField.get(primaryName)+"`"+"=?").toString();
		params.add(primaryValue);
		
		String[] sql = {finalSql};
		
		updateSqlParams.put("sql",sql);
		updateSqlParams.put("params", params.toArray());
		
		return updateSqlParams;
	}
	
}

```

```java
package guqing.basedao;
/**  
* <p>Title: Column.java</p>  
* <p>Description: </p>  
* <p>Copyright: Copyright (c) 2018</p>  
* @author guqing   
* @date 2018年9月23日  
* @version 1.0  
*/

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

/**  
* <p>Title: Column</p>  
* <p>Description: </p>  
* @author guqin  
* @date 2018年9月23日  
*/
@Retention(RetentionPolicy.RUNTIME)
public @interface Column {
	String value();
}

```

```java
package guqing.basedao;
/**  
* <p>Title: ID.java</p>  
* <p>Description: </p>  
* <p>Copyright: Copyright (c) 2018</p>  
* @author guqing   
* @date 2018年9月23日  
* @version 1.0  
*/

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

/**  
* <p>Title: ID</p>  
* <p>Description: </p>  
* @author guqin  
* @date 2018年9月23日  
*/
@Retention(RetentionPolicy.RUNTIME)
public @interface ID {
	String value();
}

```


```java
package guqing.basedao;
/**  
* <p>Title: Table.java</p>  
* <p>Description: </p>  
* <p>Copyright: Copyright (c) 2018</p>  
* @author guqing   
* @date 2018年9月23日  
* @version 1.0  
*/

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

/**  
* <p>Title: Table</p>  
* <p>Description: </p>  
* @author guqin  
* @date 2018年9月23日  
*/
@Retention(RetentionPolicy.RUNTIME)
public @interface Table {
	String value();
}

```


```java
/**  
* <p>Title: MatchField.java</p>  
* <p>Description: </p>  
* <p>Copyright: Copyright (c) 2018</p>  
* @author guqing   
* @date 2018年9月26日  
* @version 1.0  
*/ 
package guqing.basedao;

import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

/**  
* <p>Title: MatchField</p>  
* <p>Description: </p>  
* @author guqin  
* @date 2018年9月26日  
*/
public class MatchField {
	private static String primary;
	private static String primaryName;
	
	private static MatchField matchField = new MatchField();
	
	private MatchField(){}
	
	/**
	* @Title: getMatchFieldInstance  
	* @Description: 获取该对象的句柄  
	* @param @return
	* @return MatchField
	* @throws
	 */
	public static MatchField getMatchFieldInstance() {
		return matchField;
	}
	
	/**
	* @Title: MappingField2Map  
	* @Description: 字段映射函數，返回一個Map，key=對象字段名 ,value=數據庫字段名 
	* @param @param beanClass
	* @param @return
	* @return Map<String,String>
	* @throws
	 */
	public Map<String,String> MappingField2Map(Class<?> beanClass){
		Map<String,String> fieldMapping = new HashMap<String,String>();
		
		//反射获取到主键的值
		Field[] fields = beanClass.getDeclaredFields();
		for(Field field : fields){
			ID id = field.getAnnotation(ID.class);
			Column column = field.getAnnotation(Column.class);
			if(id!=null) {
				primary = id.value();
				primaryName = field.getName();
				fieldMapping.put(primaryName, primary);//對象成員變量名-->表字段名
				
			} else if(column!=null) {
				fieldMapping.put(field.getName(), column.value());
				
			} else {//如果都不是那麽默認就是字段名就是對應數據庫字段名
				fieldMapping.put(field.getName(), field.getName());
			}
		}
		
		//如果用户忘记注解主键那么抛出异常
		if(primaryName==null||primary==null){
			throw new RuntimeException("syntax error:unknown primary key columns,"
					+ " try again after annotating the primary key in the Javabean with @ID(value)");
		}
		
		return fieldMapping;
	}
	
	/**
	* @Title: precursorSelectSql  
	* @Description: 返回查询语句的前半部分  
	* @param @param beanClass
	* @param @return
	* @return String
	* @throws
	 */
	public String precursorSelectSql(Class<?> beanClass){
		//通过beanClass得到字段映射Map
		Map<String,String> mappingField = MappingField2Map(beanClass);
		
		//拿到javaBean所有成员变量
		Field[] fields = beanClass.getDeclaredFields();
		
		//创建查询语句前驱
		StringBuilder sb = new StringBuilder("select ");
		//拼凑sql语句
		for(int i=0;i<fields.length;i++){
  			sb.append("`"+mappingField.get(fields[i].getName())+"`");//通过键获得表的字段名称
  			sb.append(" as "+"`"+fields[i].getName()+"`");
  			if(i<fields.length-1){
  				sb.append(",");//最后一个不加逗号
  			}
  		}
		sb.append(" ");
		return sb.toString();
	}

	/**
	* @Title: getBeanPrimaryName  
	* @Description: 返回javabean中作为主键的成员变量名称  
	* @param @return
	* @return String
	* @throws
	 */
	public String getBeanPrimaryName(){
		return primaryName;
	}
}

```
```java
/**  
* <p>Title: Query.java</p>  
* <p>Description: </p>  
* <p>Copyright: Copyright (c) 2018</p>  
* @author guqing   
* @date 2018年9月23日  
* @version 1.0  
*/ 
package guqing.basedao;

import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**  
* <p>Title: Query</p>  
* <p>Description: </p>  
* @author guqin  
* @date 2018年9月23日  
*/
public class Query {
	private static String thatSql;
	private static List<String> entyStringsql = new LinkedList<String>();
	//存储？的下标位置
	private static Map<Integer,Integer> strIndex;
	//存储上一个参数的长度
	private static int lastParameterLeng=0;
	private Query(){}
	
	public static void setParameter(int key, String parameter) {
		try{
			if(strIndex != null){
				StringBuilder sb = new StringBuilder(Query.getThatSql());
				
				parameter = "'"+parameter+"'";
				
				if(key == 1){
					thatSql = sb.replace(strIndex.get(key), strIndex.get(key)+1, parameter).toString();
					lastParameterLeng = parameter.length()-1;
				}else{
					thatSql = sb.replace(strIndex.get(key)+lastParameterLeng, strIndex.get(key)+lastParameterLeng+1, "'"+parameter+"'").toString();
					lastParameterLeng = lastParameterLeng + parameter.length()-1;
				}
			}
		}catch(Exception e){
			throw new RuntimeException(e);
		}
	}
	
	/**
	* @Title: setParameter  
	* @Description: 重载方法通过设置【:占位词】 来设置参数  
	* @param @param key
	* @param @param parameter
	* @return void
	* @throws
	 */
	public static void setParameter(String key, String parameter) {
		try{//查找[:占位词]
			String regex = "\\:"+key;
			
			parameter = "'"+parameter+"'";
			
			//替换为parameter
			thatSql = Query.getThatSql().replaceFirst(regex, parameter);
			
		}catch(Exception e){
			throw new RuntimeException(e);
		}
	}
	
	
	/**
	* @Title: createQuery  
	* @Description: 处理sql语句，替换参数  
	* @param @param sql
	* @param @return
	* @return List<String>
	* @throws
	 */
	public static void createQuery(String mysql) {
		strIndex = searchAllIndex(mysql,"?");
		
		Pattern pattern = Pattern.compile("\\s\\w+\\s?=");
		Matcher matcher;
		matcher = pattern.matcher(mysql);
		while (matcher.find()) {
			String str_temp = matcher.group(0);
			str_temp=str_temp.substring(0, str_temp.length()-1);
			//将属性名称追加到后面
			entyStringsql.add(str_temp.trim());
		}
		thatSql = mysql;
	}
	
	/**
	* @Title: getEntyStringSql  
	* @Description: 返回  entyStringsql List集合
	* @param @return
	* @return List<String>
	* @throws
	 */
	public static List<String> getEntyStringSql(){
		return entyStringsql;
	}
	
	/**
	* @Title: getThatSql  
	* @Description: 返回用户传入的sql语句  
	* @param @return
	* @return String
	* @throws
	 */
	public static String getThatSql(){
		return thatSql;
	}
	
	/**
	* @Title: searchAllIndex  
	* @Description: 查找字符串中某个字符出现的所有位置  
	* @param @param str
	* @param @param key
	* @param @return
	* @return Map<Integer,Integer>
	* @throws
	 */
	private static Map<Integer,Integer> searchAllIndex(String str,String key) {
		Map<Integer,Integer> strIndex = new LinkedHashMap<Integer,Integer>();
		int count = 1;
        int index = str.indexOf(key);//*第一个出现的索引位置
        while (index != -1) {
        	strIndex.put(count++, index);
            index =  str.indexOf(key, index + 1);//*从这个索引往后开始第一个出现的位置
        }
        return strIndex;
    }

}

```
